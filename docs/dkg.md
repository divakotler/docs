---
pagination_next: null
pagination_prev: null
---
# Distributed Key Generation


### Creation of distributed validators

The primary purpose of the Smart Contracts is to accumulate ETH deposited into the Diva Pool, and orchestrate the creation of decentralized validators. Since a validator in Ethereum requires a minimum of 32 ETH to become active, the deposited ETH needs to be grouped in bundles of 32 ETH before creating a new validator. Every time the Smart Contracts receive some ETH, if the pool accumulates a multiple of 32 ETH, the Smart Contracts will use the $\mathtt{RANDAO}$ RANDAO value to generate one random seed per each 32 ETH bundle.

The random seed produced by the $\mathtt{RANDAO}$ is considered as $Seed_{0}$, and it won’t be used for the creation of a distributed validator. Instead, one sub-seed $ValidatorID_{x}$ is generated for each distributed validator $x$ as:

$$
ValidatorID_{x} = \mathtt{HASH}(Seed_{0})
\\
ValidatorID_{x+1} = \mathtt{HASH}(ValidatorID_{x})
$$

Where $\mathtt{HASH}$ is an instance of $\mathtt{keccak256}$. The unique identifier representing the creation of a new distributed validator in the smart contract is determined by $ValidatorID_{x}$.

Each Diva Node (node) is constantly monitoring the events coming from the DSC ordering the creation of a new distributed validator. Diva Nodes are managed by Diva Operators (operators) who deposit collateral and collect the rewards generated by the protocol.

One operator can manage multiple nodes, but the creation of new distributed validators is calculated using the identity of the operator (thus, it doesn’t depend on the number of nodes that the operator has or the identities of those nodes). Any node from any operator can participate in a Distributed Key Generation (DKG) ceremony on behalf of its operator’s identity with another group of nodes, but if multiple nodes of the same operator communicate to a single node of another operator, the other node could limit the number of requests initiated by a single operator for a given DKG UUID. This is done to prevent spamming the network with requests when some operator has many nodes. In addition to this restriction defined at the network level, operators will be able to enable or disable their nodes as potential DKG participants or not, allowing for a better load balancing between the nodes fully managed by the operator. 
To create a new distributed validator, nodes should be divided into 2 groups: participants and coordinators. To create an optimal set of DKG participants, all the nodes that want to participate in the DKG will submit a DKG request to the P2P topic $ValidatorID_{x}$. DKG coordinators will pick a set of unique participants that minimizes the value of $Weight_{min}^{total}$ defined as:

$$
Weight_{min}^{total} = \\ = min ( \sum\{Weight_{participant_i},Weight_{participant_j},...Weight_{participant_k}\} )  \\ \forall \ i,j,k \  / \  i \ne j \ne k
$$

where

$$
Weight_{participant_i}=\mathtt{XOR}
(Seed_{x}^{participants},operator_{i})
$$

$$
Seed_{x}^{participants} = \mathtt{HASH}(Seed_{x},1)
$$

$$
Set\ of\ participants = \{operator_i, operator_j, ..., operator_k\}

$$

On the other hand, all DKG coordinators will calculate which coordinator is optimal (defined as the coordinator with the lowest $Weight_{coordinator_i}$) for submitting a DKG proposal for $ValidatorID_{x}$.

$$

Weight_{coordinator_i}=\mathtt{XOR}
(Seed_{x}^{coordinators},operator_{i})
$$

$$
Seed_{x}^{coordinators} = \mathtt{HASH}(Seed_{x},0)
\\

$$

Since each coordinator knows its weight and all the other weights, it will know if it was chosen as the optimal coordinator and therefore should submit a DKG proposal transaction to the DSC. A non-optimal coordinator does not have incentives to submit a DKG proposal to the DSC unless the optimal coordinator did not submit a valid proposal. If it did submit a valid proposal, it did so with a set of non-optimal DKG participants. 

All coordinators must submit their proposal during a valid timeframe (TF).


Coordinators will also have the incentive to submit the proposal as soon as possible because the rewards assigned for the creation of a new validator are proportional to the moment in which the submission occurs. Thus, the reward will be higher the sooner the coordinator sends a DKG proposal to the smart contract. This reward decreases over time from 100% at the beginning of the submission timeframe down to 50% of the reward at the end of the timeframe.

The initial timeframe (TF1) for the submission of DKG proposals starts at the moment of generation of the validator seed, $ValidatorID_{x}$. Each timeframe lasts for 50 blocks, and the coordinator that submits a valid DKG proposal with the lowest set of DKG participants will be able to claim the creation of the distributed validator during the next timeframe (TF2). If more than 1 coordinator submits the same set of DKG participants, the coordinator with the lowest 
$Weight_{coordinator_i}$ will be the one that can claim the distributed validator during TF2. 

If the coordinator that won the previous TF does not claim the creation of the distributed validator, a new seed will be generated for $ValidatorID_{x}$ for the next TF as follows:

$Seed^{TF1}_{A} = \mathtt{HASH}(Seed_{0}) = ValidatorID_{x}$

$Seed^{TF2}_{A} = \mathtt{HASH}(Seed^{TF1}_{A},Winner_{TF1A})$

$Seed^{TF3}_{A} = \mathtt{HASH}(Seed^{TF2}_{A},Winner_{TF2A})$

$Seed^{TF1}_{B} = \mathtt{HASH}(Seed^{TF1}_{A}) = ValidatorID_{x+1}$

$Seed^{TF2}_{B} = \mathtt{HASH}(Seed^{TF1}_{B},Winner_{TF1B})$
